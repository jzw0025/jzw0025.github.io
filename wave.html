
<canvas id="wave-canvas" width="800" height="600" style="width:100%;max-width:800px;"></canvas>
<script>
async function loadShaderSource(url) {
  const response = await fetch(url);
  return await response.text();
}

function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error('Shader compile error: ' + gl.getShaderInfoLog(shader));
  }
  return shader;
}

async function main() {
  const canvas = document.getElementById('wave-canvas');
  const gl = canvas.getContext('webgl');
  if (!gl) {
    alert('WebGL not supported');
    return;
  }

  // Vertex shader (simple passthrough)
  const vertSource = `
    attribute vec2 aPosition;
    varying vec2 vUv;
    void main() {
      vUv = (aPosition + 1.0) * 0.5;
      gl_Position = vec4(aPosition, 0, 1);
    }
  `;

  // Load fragment shader from file
  const fragSource = await loadShaderSource('/assets/shaders/wave_shader2.txt');

  // Patch the loaded shader to work as a fragment shader
  const fragShaderSource = `
    precision highp float;
    uniform float iTime;
    uniform vec2 iResolution;
    varying vec2 vUv;
    ${fragSource}
    void main() {
      mainImage(gl_FragColor, gl_FragCoord.xy);
    }
  `;

  // Compile shaders
  const vertShader = createShader(gl, gl.VERTEX_SHADER, vertSource);
  const fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragShaderSource);

  // Create program
  const program = gl.createProgram();
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    alert('Program link error: ' + gl.getProgramInfoLog(program));
    return;
  }
  gl.useProgram(program);

  // Set up geometry (full screen quad)
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1, 1, -1, -1, 1,
    -1, 1, 1, -1, 1, 1
  ]), gl.STATIC_DRAW);
  const posLoc = gl.getAttribLocation(program, 'aPosition');
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

  // Uniform locations
  const iTimeLoc = gl.getUniformLocation(program, 'iTime');
  const iResolutionLoc = gl.getUniformLocation(program, 'iResolution');

  // Animation loop
  function render(time) {
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform1f(iTimeLoc, time * 0.001);
    gl.uniform2f(iResolutionLoc, canvas.width, canvas.height);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
}

main();
</script>
